---
title: "Adaptive Group Knockoff Experiments"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Precision/Graph Generation

```{r library}
# Requires Matrix, mvtnorm, dendextend

```


```{r graphgen}
#' Generates a precision for a band graph.
#' This is currently not efficient for p > 1000. 
#' See https://stat.ethz.ch/R-manual/R-devel/library/Matrix/html/Diagonal.html
#' And use kronecker products
#'
#' @param p dimensionality of data
#' @param a base of exponent in band graph
#' @param rho size of blocks in the 'band'
#' @param c parametrizes how fast values decay
BandPrecision <- function(p = 200, a = 0.9, rho = 5, c = 1.5){
  dists <- abs(replicate(p, 1:p) - t(replicate(p, 1:p)))
  Q <- sign(a) * (abs(a)**(dists/c)) * (dists <= rho)
  return(Q)
}

#' Generates Erdos-Renyi Random precision matrix 
#' Still pretty slow
#' Adjusting values makes a big difference
ErdosRenyi <- function(p = 300, delta = 0.8, 
                       values = c(-0.5, -0.3, -0.05, 0.05, 0.3, 0.5)){
  Q <- matrix(0, nrow = p, ncol = p)
  triang <- stats::rbinom((p**2 - p)/2, 1, delta) * sample(values,(p**2 - p)/2, replace = TRUE)
  Q[upper.tri(Q, diag = FALSE)] = triang
  Q[lower.tri(Q, diag = FALSE)] = triang
  Q  <- Q + diag(p)
  return(Q)
} 

```

# Sampling and Clustering

```{r}
sampleAndCluster <- function(Q, n = 500){
  
  # True parameters (assume working with centered/scaled data)
  CorrMatrix <- cov2cor(chol2inv(Q))
  
  # Create agglomerative tree
  
  X <- mvtnorm::rmvnorm(n, sigma = CorrMatrix)

  # Sample data - for now,
  # in MX setting, assume we know
  # the true covariance matrix.
  #X <- scale(X, center = TRUE, scale = TRUE)
  #sampleSigma <- (t(X) %*% X)/(n-1)
  #return(sampleSigma)

  
}

```


```{r test}

set.seed(110)

# Create precision matrix, data
p <- 30
n <- 100
Q <- ErdosRenyi(p = 30)
CorrMatrix <- cov2cor(chol2inv(Q))
X <- mvtnorm::rmvnorm(100, sigma = CorrMatrix)

# Create trees/dendrogram
distCorrMatrix <- stats::as.dist(1-abs(CorrMatrix))
tree <- hclust(distCorrMatrix, method = 'average')
dendrogram <- as.dendrogram(tree)
#plot(tree)

# For a fixed height, group data and sort by the group
# Could do this with dplyr %>% select(sort(colnames(X)))
# but currently unclear which one is more efficient
h <- 0.8
groups <- cutree(tree, h = h)
colnames(X) <- groups
sortedX <- X[, order(colnames(X))]
colnames(CorrMatrix) <- groups
sortedCorrMatrix <- CorrMatrix[order(colnames(CorrMatrix)), order(colnames(CorrMatrix))]
Sigma <- t(X) %*% X

# Equicorrelated version

```

```{r simple test}

p <- 
  
n <- 10000
beta <- 10*stats::rbinom(p, 1, 0.5)

X <- stats::rnorm(n*p)
X <- matrix(X, nrow = n, byrow = TRUE)

y <- X %*% beta + stats::rnorm(n)

knockoff.filter(X = X, y = y)

```

